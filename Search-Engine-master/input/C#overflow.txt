In dot net an overflow can occur when an arithmetic operation produces a result that is outside the range of the data type returned by the operation. Earlier we saw that when casting between number types it was possible to lose information. For example when casting from a variable of type long two and variable if the value stored in a type is too big it will overflow. The check statement tells Dattner to throw an exception when an overflow happens instead of allowing it to happen silently. Let's go ahead and take a look. How overflowing looks and an arithmetic operation so let's go ahead and create a new project under topic E.. Checking for overflow I will name this checking for overflow. Choose the right location and do quick build and set our project as the start of a project. Now what we're going to do is set the initial value of an intra variable to its maximum value minus 1 and then we will increment it several times. Outputting its value each time. So let's create a method called use the check statement I'll generate the method stub and I will paste some code doing exactly what I described. We set an initial value of an int variable to its maximum value minus one and then we're incrementing it several time outputting its value. Now what I'd like you to note is that once it gets above its maximum value it will overflow to its minimum value and continue incrementing from there. So let's run our program. But before we do so I'll jump to the top of the code and put in using static system a console. And now we can had control 5 to run and this is what I am talking about. It incremented the number but once it got to its maximum then it began incrementing it. But the numbers are negative. So this is where we can use the check statement. We can come over here and simply type in checked and open the curly braces and at the end of our code close the curly braces. And now when we run an exception will be thrown because of the overflow and there is an arithmetic operation resulted in an overflow. So as we previously learned in order to be able to handle an exception will want to place that in a try catch block. So I can grab my code and place it in the try block here. And we know the type of exception that we're looking for so we can be specific here and write overflow exception specifically. And if it gets caught instead of throwing the exception we can write out the code overflow. But I caught exception. So now when we run it writes out the first two numbers appropriately and then gives us the message that we expect related to the check statement. Is that on check statement. Let's take a look at that next. So I wanted to do a quick example of the unchecked statement. Let's create a method call use the check statement. Now if I were to come on line 16 and define a variable y with its maximum integer value like this that's OK. There's no issue there. However if I wanted to just add 10 then there's going to be a problem says the operation overflows at compile time and checked mode you see compile time overflows are checked by default. And the workaround for this would be to use uncheck Or you could use the key word right in front of your expression and put the expression in parentheses. Uncheck key word is used to suppress overflow checking in integral type arithmetic operations and conversions and what's going on is that in an unchecked context if an expression produces a value that's outside the range of the destination type the overflow is not flagged. And so if we were to debug this and step through it when we just go over this specific step you'll see that the value of y becomes a negative number just like we saw in the console application at the beginning of our last exercise overflowing. In this case is what some experts call rotational overflow. That is we can pass from one of the limits to the other limit just by adding or subtracting one from the given value. And that's what you see happening here. Either way personally I have not experienced too many instances in my long career as a developer to use this but it is good to know. Nonetheless.

