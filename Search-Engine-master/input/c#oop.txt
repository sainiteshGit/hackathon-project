We've talked about how to build and define classes then we move down to a discussion of interfaces and inheritance. This will all now come together in our discussion of understanding of what object oriented programming is. Sometimes it's referred to as OOP although that's really not my preference I'll just like to say object oriented programming and it's essentially a style of programming a programming model organize around objects and we now know that objects are data structures with fields and methods. Well there are four major pillars associated with object oriented programming and that's what we're going to address. The first is abstraction then there's polymorphism. The third one we've already discussed inheritance and the last one is encapsulation. This is another common question that comes up in interviews. What are the four pillars of object oriented programming. An easy way to remember them is the acronym pi. Let's start off with abstraction. So let's talk about abstraction. The definition may vary when you google it but in short it tends to imply that it's the process of exposing all the essential features of an entity or a class. However I'd like to now bring in the topic of another pillar encapsulation because these two are often confused with one another. The next pillar that I'd like to address in object oriented programming is polymorphism. Now polymorphism tends to be a little bit difficult to describe by a lot of different programmers and took me a while to fully understand it also. But you could think of it in terms of this. First of all the word itself means many shapes and if you were to think of a real world example of a polymorphic behavior think of a Blu ray disc player that plays DVDs if you pop in a DVD it will do what it needs in order to play that DVD. However you pop in a Blu ray disc then the behavior will be different in order to play that Blu ray disc but throughout all of this the interface of the disc player stays the same. So in that sense it's polymorphic because the behavior is dependent on what's passed into it. And in programming. Well it's classes that have different functionality while sharing the same interface. And to give a more specific example one could be an object that is passed into a method and the behavior of the method will be dependent on the type of that object. Let's go ahead and take a look at an example. So I mentioned earlier how polymorphism actually means many shapes. Well in this example I'm going to show you an example of this by demonstrating having an employee object and a contractor object the contract object will inherit from employee. And both of these objects will have calculate weekly salary methods. The exception is that the employee will not gain overtime so it will just multiply a straight 40 hour work week times an hourly rate and the contractor will multiply weekly hours times the hourly rate. So we'll start off by creating an employee class and within this employee class I'll paste in some code that you can pause a screen to type in but it will be the first determine determine weekly salary method. And all I do is pass in two parameters weekly hours and wage and then we multiply to get a salary. The wage by 40 and we ride out to the console this employee work X amount of hours. And then the total amount of money that they will make next. Let's create a contract a class. And likewise this contractor class will also have the Terman weekly salary method. And like I mentioned earlier it will be inheriting from employees so that contract there is the child class it too has these two parameters passed in and the only main difference here is that we are multiplying by weekly hours one thing that I'd like to point out is that we are using the virtual key word here in this method and what that does is it says it grants the power to allow any other child class to override that method. So our contract the class is now able to have its own version of the determent weekly salary method by using the override key word. If we did not have virtual here in the contract the class we would not be able to override the compiler would complain say cannot override an inherited member because it did not use the virtual keyword. So that's what the virtual keyword does. It allows child classes to override the method to have distinct different functionality. Now the next thing that I will do the third step will be to create a class that returns employees. So this class right here is using a list. So let me go ahead and import the collection namespace and all that's doing it's creating an instance of an employee an instance of a contractor and then it's putting both of those into the collection call everyone. And it will return that. Right now the compiler is complaining that the namespace cannot directly contain members such as fields or methods. That is because it's not in the right location. We actually need to have this right next our main method in a class before it was not in a class. Right now I'm putting it in our program class. OK. And my next step the fourth step will be to populate my main method with exactly what to do and all I will do is define our hours and our wage and then call our get employees method. Assign it to an employee's variable and then we are going to iterate through each of the employees and evoke the term weekly salary method. So now remember one of the employees is a type of employee and the other is a type of contractor. And the way we are demonstrating polymorphism is by using the right calculate method in order to reflect whether or not it is an employee or a contractor. If it's an employee this method will be called and line 33 will be the calculation used for the salary. If it is a contractor this method will be invoked and 946 will be used to determine the salary. So let's go ahead and run and see what happens. And that looks right the employee worked 50 hours paid for 40 hours and earned twenty eight hundred dollars whereas the contractor was paid for 50 hours and earned thirty five hundred. And that is a demonstration of polymorphism. The definition you often get for encapsulation is that it is about hiding a relevant details to reduce complexity. So on one hand you have hiding a relevant details versus On the other hand showing essential features. So this can be confusing because it sounds like they're trying to say the same thing. Let's go ahead and break this down through an example in code. So let's say that we have a product screen we got requirements to create a product screen and its sole purpose is to enter a product ID a name and then submit the product to the database. So by looking at this you can think OK so therefore I can create a product class that has a couple of properties product ID product name and then a method to say to the database. So with that amount Let's go onto a visual studio and write some pseudo code here I have on the right hand side you can see in the solution explorer demo abstraction console project and there's nothing in it except the static void main method. And I've also created a separate project file. It's a class library and it has a product class. So to get started we can first add in a product ID and product name. So let's go ahead and do that next. We can add a method that's supposed to have the functionality for submitting. So at this point I've only added the basic things that I've needed in the class and ID a name and the logic for submitting. I have not gone into detail about how. So let me add a comment at the top. When use three slashes like that you can write a detailed comment in a summary fashion so I thought about the what and not really the how the how can be how will I validate the ID or the name or how it will actually get save to the database. And let's do that now. Those could be a separate method a granular method for validation of the product name and the product ID. And in addition a method to connect to the database that will do whatever work is needed in order to ultimately save it to the database. So now my class is done with this pseudocode. This is just partial code just to get the idea going what needs to get done and it can be used by anyone from my perspective right now to submit a product. It has everything we need. It has nice properties for the input field and has a nice submit button logic and it has nice methods for validation and in connecting to the database. So let me go ahead and build make sure that there's no issues. So now let's use this class in our console application. So I want to go ahead navigate to demo abstraction and here I can start adding some code to use our product so I'm defining my product and the compiler is complaining. And that's simply because I need to add a reference to the product SDK class. Let's go ahead and do that now. And that took care of that. So my product is defined and I can go ahead and assign a product ID and a product name. In addition I could then come in and access my valeted method invoke that connect to the database and then submit. And so there we have it. However there is a problem validate and connect to D-B on line 13 and 14 is really complicating matters. You need to ask yourself again what what does a developer actually really need. And that is to enter the ID name and to submit. So the solution is to expose what's necessary in your console application. So what we can do. We can go over to the product class and go to validate and change this public to private. Same thing for connecting to the database. And instead within the submit method over here we can call these methods at this point. So now we can save go to our program files and get rid of these calls in our console application. And now things are cleaner. We've only exposed the minimum of what the developer and user needs. And how does this relate to abstraction and a cancellation. Well we went through a few steps. The first was asking the what. And that was the stuff we were doing abstraction. We're asking what is absolutely necessary as far as features in order to expose for the developer. When we went down and made validate and connect to be private that was encapsulation. So you can think of abstraction as a thought process asking what is absolutely necessary in terms of features to show. Meanwhile encapsulation is a process of bringing down complexity. So as we asked the what we're going through is an abstraction process. We ask the how and thought in terms of the granular methods they needed to get done. So we created those but then we went into an encapsulation process by making those methods private and therefore simplifying our consul application. So ultimately they are related abstraction encapsulation because encapsulation can implement abstraction. So again think of abstraction as a thought process. While encapsulation is implementation.

